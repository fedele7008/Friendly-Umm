#include "log_manager.h"#include <string>#include <fstream>#include <filesystem>#include <gtest/gtest.h>namespace {    using std::string;    using std::ifstream;    using std::istreambuf_iterator;    using std::filesystem::path;    using std::optional;    using std::runtime_error;    using service::LogManager;    TEST(LogManagerTest, LogManagerTestWithFileLogAbsPath) {        optional<path> logFile = path(fmt::format("{}/test.log", std::filesystem::current_path().string()));        LogManager::getInstance().initialize("LogManagerTest", logFile);        auto logger = LogManager::getInstance().getLogger();        string message = "Hello world!, this is sample {} log message";        testing::internal::CaptureStdout();        logger->trace(message, "trace");        logger->debug(message, "debug");        logger->info(message, "info");        logger->warn(message, "warn");        logger->error(message, "error");        logger->critical(message, "critical");        std::string output = testing::internal::GetCapturedStdout();        LogManager::getInstance().uninitialize();        EXPECT_EQ(output.find(fmt::format(message, "trace")), string::npos);        EXPECT_EQ(output.find(fmt::format(message, "debug")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "info")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "warn")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "error")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "critical")), string::npos);        ifstream fileStream{logFile.value().string()};        EXPECT_TRUE(fileStream.is_open());        string fileContent{(istreambuf_iterator<char>(fileStream)), istreambuf_iterator<char>()};        fileStream.close();        EXPECT_FALSE(fileStream.is_open());        EXPECT_TRUE(std::filesystem::exists(logFile.value()));        if (std::filesystem::exists(logFile.value()))            std::filesystem::remove(logFile.value());        EXPECT_FALSE(std::filesystem::exists(logFile.value()));        EXPECT_NE(fileContent.find("Log Manager initialized"), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "trace")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "debug")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "info")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "warn")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "error")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "critical")), string::npos);        EXPECT_NE(fileContent.find("Log Manager Uninitialized"), string::npos);    }    TEST(LogManagerTest, LogManagerTestWithFileLogRelPath) {        optional<path> logFile = path("test.log");        LogManager::getInstance().initialize("LogManagerTest", logFile);        auto logger = LogManager::getInstance().getLogger();        string message = "Hello world!, this is sample {} log message";        testing::internal::CaptureStdout();        logger->trace(message, "trace");        logger->debug(message, "debug");        logger->info(message, "info");        logger->warn(message, "warn");        logger->error(message, "error");        logger->critical(message, "critical");        std::string output = testing::internal::GetCapturedStdout();        LogManager::getInstance().uninitialize();        EXPECT_EQ(output.find(fmt::format(message, "trace")), string::npos);        EXPECT_EQ(output.find(fmt::format(message, "debug")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "info")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "warn")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "error")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "critical")), string::npos);        ifstream fileStream{logFile.value().string()};        EXPECT_TRUE(fileStream.is_open());        string fileContent{(istreambuf_iterator<char>(fileStream)), istreambuf_iterator<char>()};        fileStream.close();        EXPECT_FALSE(fileStream.is_open());        EXPECT_TRUE(std::filesystem::exists(logFile.value()));        if (std::filesystem::exists(logFile.value()))            std::filesystem::remove(logFile.value());        EXPECT_FALSE(std::filesystem::exists(logFile.value()));        EXPECT_NE(fileContent.find("Log Manager initialized"), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "trace")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "debug")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "info")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "warn")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "error")), string::npos);        EXPECT_NE(fileContent.find(fmt::format(message, "critical")), string::npos);        EXPECT_NE(fileContent.find("Log Manager Uninitialized"), string::npos);    }    TEST(LogManagerTest, LogManagerTestWithoutFileLog) {        LogManager::getInstance().initialize("LogManagerTest");        auto logger = LogManager::getInstance().getLogger();        string message = "Hello world!, this is sample {} log message";        testing::internal::CaptureStdout();        logger->trace(message, "trace");        logger->debug(message, "debug");        logger->info(message, "info");        logger->warn(message, "warn");        logger->error(message, "error");        logger->critical(message, "critical");        std::string output = testing::internal::GetCapturedStdout();        LogManager::getInstance().uninitialize();        EXPECT_EQ(output.find(fmt::format(message, "trace")), string::npos);        EXPECT_EQ(output.find(fmt::format(message, "debug")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "info")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "warn")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "error")), string::npos);        EXPECT_NE(output.find(fmt::format(message, "critical")), string::npos);    }    TEST(LogManagerTest, LogManagerMultipleInitExceptionTest) {        LogManager::getInstance().initialize("LogManagerTest");        try {            LogManager::getInstance().initialize("LogManagerTest");            LogManager::getInstance().uninitialize();            FAIL() << "Expected runtime exception";        } catch (const runtime_error& e) {            EXPECT_EQ(e.what(), string{"LogManager already initialized"});        } catch (...) {            LogManager::getInstance().uninitialize();            FAIL() << "Expected runtime exception";        }        LogManager::getInstance().uninitialize();    }    TEST(LogManagerTest, LogManagerUninitBeforeInitExceptionTest) {        try {            LogManager::getInstance().uninitialize();            FAIL() << "Expected runtime exception";        } catch (const runtime_error& e) {            EXPECT_EQ(e.what(), string{"LogManager not initialized"});        } catch (...) {            FAIL() << "Expected runtime exception";        }    }    TEST(LogManagerTest, LogManagerGetLoggerBeforeInitExceptionTest) {        try {            LogManager::getInstance().getLogger();            FAIL() << "Expected runtime exception";        } catch (const runtime_error& e) {            EXPECT_EQ(e.what(), string{"LogManager not initialized"});        } catch (...) {            FAIL() << "Expected runtime exception";        }    }} // namespace